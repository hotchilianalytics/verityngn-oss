"""
API Routes for serving verification reports.

This module provides FastAPI endpoints to serve HTML, JSON, and Markdown reports
generated by VerityNgn, making all links in HTML reports work correctly.
"""

import logging
import os
import json
from pathlib import Path
from typing import Optional
from fastapi import APIRouter, HTTPException
from fastapi.responses import Response, FileResponse, JSONResponse

from verityngn.config.settings import STORAGE_BACKEND, StorageBackend
from verityngn.services.storage.timestamped_storage import timestamped_storage

router = APIRouter()
logger = logging.getLogger(__name__)

# Cache behavior logging
cache_logger = logging.getLogger("cache_behavior")


def log_cache_decision(video_id: str, filename: str, decision: str, details: dict):
    """Log cache serving decisions for debugging."""
    cache_logger.info(
        f"[CACHE] Video: {video_id} | File: {filename} | Decision: {decision} | Details: {details}"
    )


def get_latest_report_file(video_id: str, filename: str) -> Optional[str]:
    """
    Get the latest complete report file using timestamped storage.
    
    Args:
        video_id: Video identifier
        filename: Name of the file to retrieve
        
    Returns:
        Optional[str]: File content, or None if not found
    """
    try:
        # Find the latest complete report directory
        latest_dir = timestamped_storage.find_latest_complete_report(video_id)
        
        if not latest_dir:
            cache_logger.warning(
                f"[TIMESTAMPED] No complete reports found for video {video_id}"
            )
            return None
        
        # Get the file from the latest directory
        content = timestamped_storage.get_report_file_from_timestamped_dir(
            latest_dir, filename
        )
        
        if content:
            cache_logger.info(
                f"[TIMESTAMPED] Served {filename} from latest complete report: {latest_dir}"
            )
        else:
            cache_logger.warning(
                f"[TIMESTAMPED] File {filename} not found in latest directory: {latest_dir}"
            )
        
        return content
        
    except Exception as e:
        cache_logger.error(f"[TIMESTAMPED] Error getting latest report file: {e}")
        return None


def _find_report_file_fallback(video_id: str, filename: str) -> Optional[Path]:
    """
    Fallback method to find report files directly from filesystem.
    
    Checks outputs_debug directory for local storage.
    """
    if STORAGE_BACKEND == StorageBackend.LOCAL:
        # Check outputs_debug directory
        outputs_debug = Path("verityngn/outputs_debug")
        if outputs_debug.exists():
            video_dir = outputs_debug / video_id
            if video_dir.exists():
                # Look for timestamped directories
                for complete_dir in sorted(
                    video_dir.glob("*_complete"),
                    key=lambda x: x.stat().st_mtime,
                    reverse=True,
                ):
                    file_path = complete_dir / filename
                    if file_path.exists():
                        return file_path
                
                # Fallback to direct file
                file_path = video_dir / filename
                if file_path.exists():
                    return file_path
    
    return None


@router.get("/{video_id}/report.html")
async def get_report_html(video_id: str):
    """
    Get the HTML report for a video.
    Uses timestamped storage to always serve the latest complete report.
    
    Args:
        video_id (str): The video ID
        
    Returns:
        Response: The HTML report
    """
    try:
        # Try different HTML report filenames
        html_filenames = [
            f"{video_id}_final_report.html",
            f"{video_id}_report.html",
        ]
        
        for filename in html_filenames:
            # Try to get from timestamped storage first
            content = get_latest_report_file(video_id, filename)
            
            if content:
                cache_details = {
                    "content_length": len(content),
                    "serving_method": "timestamped_latest_complete",
                }
                log_cache_decision(
                    video_id, filename, "SERVED_FROM_TIMESTAMPED_STORAGE", cache_details
                )
                return Response(content=content, media_type="text/html")
            
            # Fallback: Try direct file access
            file_path = _find_report_file_fallback(video_id, filename)
            if file_path:
                cache_details = {
                    "local_path": str(file_path),
                    "serving_method": "direct_file_fallback",
                }
                log_cache_decision(
                    video_id, filename, "SERVED_FROM_DIRECT_FILE", cache_details
                )
                return FileResponse(file_path, media_type="text/html")
        
        raise HTTPException(status_code=404, detail="HTML report not found")
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error getting HTML report: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/{video_id}/report.json")
async def get_report_json(video_id: str):
    """
    Get the JSON report data for a video.
    Uses timestamped storage to always serve the latest complete report.
    
    Args:
        video_id (str): The video ID
        
    Returns:
        JSONResponse: The JSON report data
    """
    try:
        # Try different JSON report filenames
        json_filenames = [
            f"{video_id}_final_report.json",
            f"{video_id}_report.json",
        ]
        
        for filename in json_filenames:
            # Try to get from timestamped storage first
            content = get_latest_report_file(video_id, filename)
            
            if content:
                try:
                    report_data = json.loads(content)
                    cache_details = {
                        "content_length": len(content),
                        "serving_method": "timestamped_latest_complete",
                    }
                    log_cache_decision(
                        video_id,
                        filename,
                        "SERVED_FROM_TIMESTAMPED_STORAGE",
                        cache_details,
                    )
                    logger.info(f"Serving JSON report for video: {video_id}")
                    return JSONResponse(content=report_data)
                except json.JSONDecodeError as e:
                    logger.error(f"Invalid JSON in timestamped report file: {e}")
                    continue
            
            # Fallback: Try direct file access
            file_path = _find_report_file_fallback(video_id, filename)
            if file_path:
                try:
                    with open(file_path, "r", encoding="utf-8") as f:
                        report_data = json.load(f)
                    cache_details = {
                        "local_path": str(file_path),
                        "serving_method": "direct_file_fallback",
                    }
                    log_cache_decision(
                        video_id, filename, "SERVED_FROM_DIRECT_FILE", cache_details
                    )
                    return JSONResponse(content=report_data)
                except json.JSONDecodeError as e:
                    logger.error(f"Invalid JSON in report file: {e}")
                    continue
        
        raise HTTPException(status_code=404, detail="JSON report not found")
        
    except HTTPException:
        raise
    except json.JSONDecodeError as e:
        logger.error(f"Invalid JSON in report file: {e}")
        raise HTTPException(status_code=500, detail="Invalid JSON in report file")
    except Exception as e:
        logger.error(f"Error getting JSON report: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/{video_id}/report.md")
async def get_report_md(video_id: str):
    """
    Get the Markdown report for a video.
    Uses timestamped storage to always serve the latest complete report.
    
    Args:
        video_id (str): The video ID
        
    Returns:
        Response: The Markdown report
    """
    try:
        # Try different MD report filenames
        md_filenames = [
            f"{video_id}_final_report.md",
            f"{video_id}_report.md",
        ]
        
        for filename in md_filenames:
            # Try to get from timestamped storage first
            content = get_latest_report_file(video_id, filename)
            
            if content:
                cache_details = {
                    "content_length": len(content),
                    "serving_method": "timestamped_latest_complete",
                }
                log_cache_decision(
                    video_id, filename, "SERVED_FROM_TIMESTAMPED_STORAGE", cache_details
                )
                return Response(content=content, media_type="text/markdown")
            
            # Fallback: Try direct file access
            file_path = _find_report_file_fallback(video_id, filename)
            if file_path:
                cache_details = {
                    "local_path": str(file_path),
                    "serving_method": "direct_file_fallback",
                }
                log_cache_decision(
                    video_id, filename, "SERVED_FROM_DIRECT_FILE", cache_details
                )
                return FileResponse(file_path, media_type="text/markdown")
        
        raise HTTPException(status_code=404, detail="Markdown report not found")
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error getting Markdown report: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/{video_id}/claim/{claim_id}/sources.html")
async def get_claim_sources_html(video_id: str, claim_id: str):
    """
    Get the claim sources HTML file for a specific claim.
    Uses timestamped storage to always serve the latest complete report.
    
    Args:
        video_id (str): The video ID
        claim_id (str): The claim ID (e.g., 'claim_0', 'claim_1', etc.)
        
    Returns:
        Response: The claim sources HTML file
    """
    try:
        filename = f"{video_id}_{claim_id}_sources.html"
        
        # Try to get from timestamped storage first
        content = get_latest_report_file(video_id, filename)
        
        if content:
            cache_details = {
                "content_length": len(content),
                "serving_method": "timestamped_latest_complete",
            }
            log_cache_decision(
                video_id, filename, "SERVED_FROM_TIMESTAMPED_STORAGE", cache_details
            )
            return Response(content=content, media_type="text/html")
        
        # Fallback: Try direct file access
        file_path = _find_report_file_fallback(video_id, filename)
        if file_path:
            cache_details = {
                "local_path": str(file_path),
                "serving_method": "direct_file_fallback",
            }
            log_cache_decision(
                video_id, filename, "SERVED_FROM_DIRECT_FILE", cache_details
            )
            return FileResponse(file_path, media_type="text/html")
        
        raise HTTPException(
            status_code=404, detail=f"HTML claim sources not found for {claim_id}"
        )
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error getting HTML claim sources: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/{video_id}/claim/{claim_id}/sources.md")
async def get_claim_sources(video_id: str, claim_id: str):
    """
    Get the claim sources markdown file for a specific claim.
    Uses timestamped storage to always serve the latest complete report.
    
    Args:
        video_id (str): The video ID
        claim_id (str): The claim ID (e.g., 'claim_0', 'claim_1', etc.)
        
    Returns:
        Response: The claim sources markdown file
    """
    try:
        filename = f"{video_id}_{claim_id}_sources.md"
        
        # Try to get from timestamped storage first
        content = get_latest_report_file(video_id, filename)
        
        if content:
            cache_details = {
                "content_length": len(content),
                "serving_method": "timestamped_latest_complete",
            }
            log_cache_decision(
                video_id, filename, "SERVED_FROM_TIMESTAMPED_STORAGE", cache_details
            )
            return Response(content=content, media_type="text/markdown")
        
        # Fallback: Try direct file access
        file_path = _find_report_file_fallback(video_id, filename)
        if file_path:
            cache_details = {
                "local_path": str(file_path),
                "serving_method": "direct_file_fallback",
            }
            log_cache_decision(
                video_id, filename, "SERVED_FROM_DIRECT_FILE", cache_details
            )
            return FileResponse(file_path, media_type="text/markdown")
        
        raise HTTPException(
            status_code=404, detail=f"Claim sources not found for {claim_id}"
        )
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error getting claim sources: {e}")
        raise HTTPException(status_code=500, detail=str(e))


















